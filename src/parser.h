#pragma once

#include "datatypes.h"

enum { MAX_YAML_LINE_LENGTH = 64 };
enum { MAX_YAML_NUM_LINES = 1024 };
enum { NUM_YAML_FILE_SECTIONS = 3 };  // rules, image location, tiles
enum {
  NUM_RULES = 2
};  // allow 90 degree rotations, allow 180 degree
    // rotations

/**
 * Get the text from the input yaml file
 *
 * Given the pointer to the user submitted yaml file, generate a split_yaml
 * struct containing the rules section, imdir section, and tiles sections of the
 * input.
 *
 * @param input_yaml_file The pointer to the file object representing the input
 * yaml
 *
 * @return The pointer to the split_yaml struct containing the contents of the
 * input yaml split into sections
 */
split_yaml* get_text_split_sections(FILE* input_yaml_file);

/**
 * Parses the "rules" section of the input text.
 *
 * Given the pointer to the rules text, determine the status of the rules
 * (currently if 90 and 180 degree rotations are allowed). Return an array of
 * ints corresponding to the rule statuses.
 *
 * The values in the return array correspond to:
 * [0]: 90 degree rotations
 * [1]: 180 degree rotations
 *
 * @param rules_text The block of text containing the rules input, no trailing
 * empty lines after it.
 *
 * @return An array of ints corresponding to rules statuses
 */
int* parse_rules_section(char** rules_text);

/**
 * Parses the "image location" section of the input text.
 *
 * Given the pointer to the image location text, determine the location of the
 * images. Return a string corresponding to that location, with a trailing
 * forward slash.
 *
 * @param image_location_text The section of the text containing the image
 * location text, no trailing lines after it.
 *
 * @return The string corresponding to the location of the images with a
 * trailing forward slash.
 */
char* parse_im_location_section(char** image_location_text);

/**
 * Parses the "tiles" section of the input text.
 *
 * Given the pointer to the tiles text and an int pointer to be written to,
 * split the tiles text into one block for each tile containing the "im_name"
 * and "edges" lines and set num_tile_configs to that number of blocks.
 *
 * @param tile_text The section of text containing the tiles text.
 * @param num_tile_configs An int pointer to be written to with the number of
 * "tile configs"/blocks this function creates
 *
 * @return An array of arrays of strings, each of the subarrays containing one
 * tile configuration block of text
 */
char*** parse_tiles_section(char** tile_text, int* num_tile_configs);

/**
 * Parses a configuration textblock for a tile as returned from
 * parse_tile_section.
 *
 * Given the pointer to a tile configration textblock, get the corresponding
 * image name and edges.
 *
 * @param tile_config_text An array of strings, the first being the "image name"
 * line for the tile config block from the yaml and the second the "edges" line
 * @param image_location The directory (with trailing backslash) containing the
 * images
 *
 * @return An array of strings, the first being the image location and the
 * second being the edges
 */
char** parse_individual_tile_config_textblock(char** tile_config_text,
                                              char* image_location);

/**
 * Creates tile struct(s) for the given edges based on the defined rules.
 *
 * Creates an array of tile pointers, number depending on rules. All tiles
 * generated by a call of this function have the same im_name and same set of
 * edges (but rotated).
 *
 * @param edges_ The edges of the tile in its unrotated state
 * @param rules The rules to be followed while generating tiles (such as whether
 * or not rotations are allowed)
 * @param im_name The name of the image file associated with this tile
 * @param num_generated Written to, the number of tiles this function generates
 *
 * @return An array of tile pointers, generated from the input edges, rules, and
 * image name
 */
tile** generate_tile_rotations(char* edges_, int* rules, char* im_name,
                               size_t* num_generated);

/**
 * Add an array of tile pointers to an existing array of tile structs.
 *
 * Extend the array and add the new tile pointers to the end. Also update the
 * variable storing the length of the array. Frees the array that is added.
 *
 * @param current_array The array to extend
 * @param num_added_tiles The number of tiles being added to the array
 * @param array_to_add The array being added to the end of the existing one
 * @param curr_len The current length of current_array, gets updated
 *
 * @return The updated tile array
 */
tile** add_to_tile_pointer_array(tile** current_array, size_t num_added_tiles,
                                 tile** array_to_add, size_t* curr_len);

/**
 * Generate tiles from a user submitted yaml input file
 *
 * Given the name of a user submitted yaml file, generate an array of tile
 * struct pointers corresponding to the tiles specified by the input yaml. The
 * parsing is brittle and requires precise formatting. If the tile generation is
 * not successful, error and exit without returning and provide the user as much
 * insight as possible as to why the parsing fails.
 *
 * Frees all memory internally allocated except for the returned tile array
 *
 * @param input_yaml_filename The name of the yaml file (or path to it including
 * name)
 *
 * @return The array of tile pointers generated from the yaml
 */
tile** generate_tiles(char* input_yaml_filename);
